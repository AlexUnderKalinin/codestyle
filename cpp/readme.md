# Правила оформления Python-кода

1. [Заголовочные файлы](#1-Заголовочные-файлы)
2. [Точки с запятой](#2-Точки-с-запятой)
3. [Скобки](#3-Скобки)
4. [Пробелы в выражениях и инструкциях](#4-Пробелы-в-выражениях-и-инструкциях)  
   4.1. [Пробелы и скобки](#41-Пробелы-и-скобки)  
   4.2. [Пробелы рядом с запятой, точкой с запятой и точкой](#42-Пробелы-рядом-с-запятой-точкой-с-запятой-и-точкой)  
   4.3. [Пробелы вокруг бинарных операторов](#43-Пробелы-вокруг-бинарных-операторов)  
5. [Длина строк](#5-Длина-строк)
6. [Пустые строки](#6-Пустые-строки)
7. [Имена](#7-Имена)  
   7.1. [Имена функций](#71-Имена-функций)  
   7.2. [Имена модулей и пакетов](#72-Имена-модулей-и-пакетов)  
   7.3. [Имена классов](#73-Имена-классов)  
   7.4. [Имена констант](#74-Имена-констант)  
8. [Комментарии](#8-Комментарии)  
   8.1. [Блоки комментариев](#81-Блоки-комментариев)  
   8.2. [Комментарии в строке с кодом](#82-Комментарии-в-строке-с-кодом)  
   8.3. [Строки документации](#83-Строки-документации)  
9. [Циклы](#9-Циклы)  
   9.1. [Циклы по спискам](#91-Циклы-по-спискам)  
   9.2. [Циклы по списку чисел](#92-Циклы-по-списку-чисел)  
   9.3. [Циклы по спискам с индексами](#93-Циклы-по-спискам-с-индексами)  
   9.4. [Циклы по двум спискам](#94-Циклы-по-двум-спискам)  
10. [Импорты](#10-Импорты)  

## 1. Заголовочные файлы
В общем случае каждому файлу исходного кода (`.cpp`) должен соответствовать заголовочный файл (`.h`). Бывают исключения - например, файл `main.cpp`, который содержит точку входа - функцию `main`

### 1.1. Include guards
Каждый заголовочный файл должен содержать include guard - конструкцию, которая не позволяет подключать файл более одного раза

Если для реализации include guard используются директивы `#ifndef` и `#define`, то название символьной константы должно составляться следующим образом: `<PROJECT>_<PATH>_<FILE>_H_`

Например, для файла `foo\src\bar\baz.h` в проекте `foo`:

**Хорошо**
```cpp
#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_
...
#endif  // FOO_BAR_BAZ_H_
```

**Плохо**
```cpp
#ifndef BAZ
#define BAZ
...
#endif  // BAZ
```
### 1.2. Подключайте то, что используете
Если вы пользуетесь какой-то сущностью, объявленной извне - подключайте тот заголовочный файл, в котором эта сущность объявлена. Больше никаких причин для подключения заголовочного файла не существует

Не надейтесь на транзитивные подключения (когда заголовочный файл, который содержит нужную вам сущность, уже подключён в другом заголовочном файле, который вы уже подключили)

```cpp
// bar.h
# pragma once
class Bar { }
```
```cpp
// foo.h
# pragma once
#include "bar.h"
class Foo
{
public:
	Foo(Bar bar);
}
```
**Хорошо**
```cpp
// main.cpp
#include "foo.h"
#include "bar.h"

int main(int argc, char** argv)
{
	Bar bar;
	Foo foo(bar);
}
```

**Плохо**
```cpp
// main.cpp
#include "foo.h"

int main(int argc, char** argv)
{
	Bar bar;
	Foo foo(bar);
}
```
### 1.3. Порядок подключения
Подключайте заголовочные файлы в следующем порядке:
 - ассоциированный с текущим файлом исходного кода заголовочный файл
 - системные заголовочные файлы C
 - заголовочные файлы стандартной библиотеки C++
 - заголовочные файлы остальных библиотек
 - заголовочные файлы вашего проекта

Все вышеперечисленные группы разделяются пустой строкой (в случае, если они не пустые)

Избегайте использования относительных директорий (`.` и `..`) для определения пути к заголовочному файлу вашего проекта - указывайте путь, начиная с корня проекта

Например, блок подключения заголовочных файолов в файле `foo-project/src/foo/internal/fooserver.cpp`

**Хорошо**
```cpp
#include "foo/server/fooserver.h"

#include <sys/types.h>
#include <unistd.h>

#include <string>
#include <vector>

#include "base/basictypes.h"
#include "foo/server/bar.h"
#include "third_party/absl/flags/flag.h"
```
**Плохо**
```cpp
#include <sys/types.h>
#include "foo/server/bar.h"
#include "third_party/absl/flags/flag.h"
#include <unistd.h>
#include "base/basictypes.h"
#include <string>
#include "foo/server/fooserver.h"
#include <vector>
```

## 2. Области видимости
### 2.1. Пространства имён
Правило, для которого есть редкие исключения, гласит - всегда пишите код внутри пространства имён

Пространства имён должны иметь уникальное название, основанное на названии проекта и, по возможности, пути внутри проекта

Не используйте директивы `using` (например, `using namespace foo`)

Не используйте `inline` пространства имён

### 2.2. Локальные переменные
Инициализируйте локальные переменные при объявлении
**Хорошо**
```cpp
int j = g();
```
**Плохо**
```cpp
int i;
i = f();
```

Используйте списки инициализации
**Хорошо**
```cpp
std::vector<int> v = {1, 2};
```
**Плохо**
```cpp
std::vector<int> v;
v.push_back(1);
v.push_back(2);
```

Объявляйте переменные там, где они нужны - в самой узкой области видимости, которая возможна
**Хорошо**
```cpp
while (const char* p = strchr(str, '/')) str = p + 1;
```
**Плохо**
```cpp
const char* p = nullptr;
while (p = strchr(str, '/')) str = p + 1;
```

Есть исключение из этого правила - если переменная является экземпляром класса, и вы объявляете (и создаёте) её в цикле, то конструктор и деструктор этого класса будет вызываться при каждой итерации цикла, что негативно скажется на производительности

**Хорошо**
```cpp
Foo f;
for (int i = 0; i < 1000000; ++i)
{
  f.DoSomething(i);
}
```
**Плохо**
```cpp
for (int i = 0; i < 1000000; ++i)
{
  Foo f;
  f.DoSomething(i);
}
```

## 3. Классы
Избегайте вызовов виртуальных методов внутри конструктора - во время работы конструктора объект ещё не создан полностью

Избегайте неявных преобразований. Используйте ключевое слово `explicit` для операторов преобразования и конструкторов с одним аргументом

Используйте структуры (`struct`) для классов без поведения, которые нужны только для хранения данных. В остальных случаях используйте классы (`class`)

Композиция (использование экземпляра одного класса внутри другого) часто является более подходящей, нежели наследование. При использовании наследования - делайте его публичным (`public`)

Определение класса обычно начинается с секции `public`, затем идёт `protected` и потом `private`
Внутри каждой секции группируйте члены класса одного рода, придерживаясь следующего порядка:
1. Типы и псевдонимы типов (`typedef`, `using`, `enum`, внутренние структуры и классы, дружественные (`friend`) типы
2. Статические константы
3. Фабричные методы
4. Конструкторы и операторы присвоения
5. Деструктор
6. Остальные методы (статические, нестатические, дружественные)
7. Поля (статические и нестатические)


## 4. Функции
Предпочительнее возвращать результат работы функции с помощью возвращаемого значения, чем с помощью выходного параметра

**Хорошо**
```cpp
int sum(int a, int b);
```
**Плохо**
```cpp
void sum(int a, int b, int& sum);
```

Лучше возвращать результат по значению. Если это невозможно, то лучше по ссылке, чем с помощью указателя. Возвращать значение с помощью указателя можно в случае, если оно может быть равно `nullptr`


Предпочтительнее использовать маленькие однозадачные функции. Если функция получается длинной, подумайте о том, можно ли её разбить на несколько

Не стоит использовать аргументы по умолчанию в виртуальных методах, так как наследники могут переопределить значение по умолчанию, что в итоге может запутать программиста

## 5. Наименование и синтаксис
